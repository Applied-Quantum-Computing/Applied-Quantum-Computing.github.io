<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Deutsch-Jozsa Algorithm: Real Life Speed Test | Applied Quantum Computation</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Deutsch-Jozsa Algorithm: Real Life Speed Test" />
<meta name="author" content="AJ Rasmusson" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Deutsch-Jozsa Algorithm In Real Life" />
<meta property="og:description" content="Deutsch-Jozsa Algorithm In Real Life" />
<link rel="canonical" href="http://localhost:4000/2020/04/06/Real-Life-Deutsch-Jozsa-Exponential-Speed-up-Test.html" />
<meta property="og:url" content="http://localhost:4000/2020/04/06/Real-Life-Deutsch-Jozsa-Exponential-Speed-up-Test.html" />
<meta property="og:site_name" content="Applied Quantum Computation" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-06T00:00:00-04:00" />
<script type="application/ld+json">
{"description":"Deutsch-Jozsa Algorithm In Real Life","@type":"BlogPosting","headline":"Deutsch-Jozsa Algorithm: Real Life Speed Test","dateModified":"2020-04-06T00:00:00-04:00","datePublished":"2020-04-06T00:00:00-04:00","url":"http://localhost:4000/2020/04/06/Real-Life-Deutsch-Jozsa-Exponential-Speed-up-Test.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/04/06/Real-Life-Deutsch-Jozsa-Exponential-Speed-up-Test.html"},"author":{"@type":"Person","name":"AJ Rasmusson"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Applied Quantum Computation" />
    





  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Applied Quantum Computation</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/tags/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline" align="center">Deutsch-Jozsa Algorithm: Real Life Speed Test</h1>
    <p align="center">Source code can be found <a href="https://github.com/ajrazander/algorithms/blob/master/Deutsch-Jozsa%20Exponential%20Speed-up%20Comparison.ipynb">here</a></p>
    <p>
    
      
      <a href="/tags/#deutsch"><code class="highligher-rouge"><nobr>deutsch</nobr></code>&nbsp;</a>
    
      
      <a href="/tags/#deutsch-jozsa"><code class="highligher-rouge"><nobr>deutsch-jozsa</nobr></code>&nbsp;</a>
    
      
      <a href="/tags/#exponential-speedup"><code class="highligher-rouge"><nobr>exponential-speedup</nobr></code>&nbsp;</a>
    
      
      <a href="/tags/#algorithm"><code class="highligher-rouge"><nobr>algorithm</nobr></code>&nbsp;</a>
    
      
      <a href="/tags/#15-qubit"><code class="highligher-rouge"><nobr>15-qubit</nobr></code>&nbsp;</a>
    
      
      <a href="/tags/#5-qubit"><code class="highligher-rouge"><nobr>5-qubit</nobr></code>&nbsp;</a>
    
    </p>
    <p class="post-meta"  align="center">
      <time class="dt-published" datetime="2020-04-06T00:00:00-04:00" itemprop="datePublished">Apr 6, 2020
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">AJ Rasmusson</span></span></p>
    <p class="post-meta">
      Last post I went through the Deutsch-Jozsa algorithm and said it's exponentially faster than any classical algorithm. Here I put that to the test with speed tests between my classical laptop and IBM's 5 and 15 qubit quantum computers. It's fun to hear how quantum computing algorithms can outpace classical algorithms, but it's even sweeter in action. Enjoy! :D

    </p>
  </header>
  <br><br><br>
  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="deutsch-jozsa-algorithm-in-real-life">Deutsch-Jozsa Algorithm In Real Life</h1>

<p>Deutsch’s algorithm, which was later generalized to the Deutsch-Josza algorithm, was the first quantum algorithm with an exponential speed-up compared to any classical algorithm. That’s what made it a big deal even though it doesn’t answer a useful question. It showed that there probably exists a quantum algorithm that is exponentially faster AND solves a useful question. In my <a href="https://appliedqc.org/2020/02/27/Deutsch-Jozsa-Algorithm.html">last post</a>, I went through the algorithm but <strong>something was missing</strong>. If the big news about Deutsch-Jozsa is that it’s exponentially faster than a classical computer then I should do some time trials to see if that’s really true: <strong>CLASSICAL</strong> vs. <strong>QUANTUM</strong>. Let’s get to it!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
</code></pre></div></div>

<h2 id="review-deutsch-jozsa-problem-and-algorithm">Review: Deutsch-Jozsa Problem (and algorithm)</h2>
<p>The problem goes like this: Given an unknown binary function <script type="math/tex">f(x)</script> (aka black box or oracle) that maps <script type="math/tex">n</script> input bits to one output bit, i.e. <script type="math/tex">f(x):\{0,1\}^n \rightarrow\{0,1\}</script>, determine if <script type="math/tex">f(x)</script> is constant or balanced. A constant function means no matter what binary number <script type="math/tex">x</script> we input, <script type="math/tex">f(x)</script> will always output the same value. A balanced function means half of all possible input <script type="math/tex">x</script>’s give <script type="math/tex">f(x)=0</script> while the other half give <script type="math/tex">f(x)=1</script>.</p>

<h3 id="quantum-algorithm">Quantum Algorithm</h3>
<p>And, if you remember, the algorithm went something like this:
<img src="/assets/images/Deutsch-Jozsa_algo.png" alt="png" />
The output qubit (at the bottom) is ‘marked’ by applying the x gate. Then the qubits are parallelized with the column of H’s into an equal superposition of all possible input and output states. Since the output qubit was marked, it has a different phase from the superposition of the input qubits. <script type="math/tex">U_f</script> imprints <script type="math/tex">f(x)</script> as a phase in the superposition state of the qubits (phase kickback). The second column of H’s interferes the superposition state with itself so the the input qubits’ final state—if you do the math—is all 0’s <strong>only</strong> for a constant function. If we measure <strong>any other</strong> state from the input qubits, we know <script type="math/tex">f(x)</script> is a balanced function.</p>

<h3 id="classical-algorithm">Classical Algorithm</h3>
<p>The classical way to determine if <script type="math/tex">f(x)</script> is constant or balanced is to randomly input binary numbers until either: (1) the function has output both a <script type="math/tex">0</script> and <script type="math/tex">1</script> or (2) we get the same output after trying one more than half of all possible inputs (<script type="math/tex">2^{n-1}+1</script> possibilities). For case (1), since the function output a <script type="math/tex">0</script> and <script type="math/tex">1</script>, we know it must be balanced. For case (2), the function output the same value for one more than half of all possible inputs, so <script type="math/tex">f(x)</script> cannot be balanced. Since there are only two options for what <script type="math/tex">f(x)</script> is, <script type="math/tex">f(x)</script> must be constant.</p>

<p>Notice the worst case scenario is when the algorithm will takes <script type="math/tex">2^{n-1}+1</script> executions of <script type="math/tex">f(x)</script>, which is EVERY time <script type="math/tex">f(x)</script> is a constant function. However, if <script type="math/tex">f(x)</script> is balanced, the classical algorithm could detect this WAY before <script type="math/tex">2^{n-1}+1</script> executions. In fact, the best case scenario is just <script type="math/tex">2</script> executions.</p>

<p>Obviously, if the classical algorithm finds the answer in <script type="math/tex">2</script> executions, current quantum computers don’t have chance at beating them. Let’s help the quantum computer out by <strong>just</strong> doing <strong>constant functions</strong>. Yes, the classical algorithm is exponentially slower, but if each execution is million times faster than a current quantum computers… maybe the classical algorithm still takes less time overall against current quantum computers. Maybe <script type="math/tex">n</script> has to be like… a billion or something astronomical before a quantum computer beats out a classical one. So, our quest becomes: <strong>At what point would a quantum computer beat out a classical computer and is that point accessible with today’s quantum computers?</strong></p>

<h2 id="define-constant-functions">Define Constant Functions</h2>
<p>Our first step is to build a constant function that can be run on a classical and quantum computer. Which turns out to be very easy to do for both types of computers. For classical, totally ignore the input and have the function always return <script type="math/tex">0</script> or always return <script type="math/tex">1</script>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Two possible constant functions for a classical computer
</span><span class="k">def</span> <span class="nf">f_const0</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">f_const1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>
</code></pre></div></div>

<h2 id="deterministic-classical-algorithm">Deterministic Classical Algorithm</h2>
<p>The classical algorithm will unknowingly ingest a constant function <script type="math/tex">f</script> and the number of input bits <script type="math/tex">n</script>. I’d like it to randomly choose binary numbers to input, but when I did that for ~<script type="math/tex">n>20</script> my laptop took a looonnnng time just to generate the random numbers—not including the time to input them into the function. If we were considering balanced functions, I’d bite the bullet and definitely do random inputs… But, since we know the functions are constant, ;) we’ll just start from <script type="math/tex">0</script> and increment up to <script type="math/tex">2^{n-1}+1</script>! (I left the random number generating in there in case anyone wanted to try it out. just replace <code class="language-plaintext highlighter-rouge">for x in non_random_inputs:</code> with <code class="language-plaintext highlighter-rouge">for x in random_inputs:</code> and uncomment the definition of the random_inputs array).</p>

<p>If the algorithm loop gets to the <script type="math/tex">2^{n-1}+1</script>th input (one more than half the possible binary numbers for the given <script type="math/tex">n</script>) and gets the same output from <script type="math/tex">f(x)</script> every time, it’ll return a 0 indicating <script type="math/tex">f(x)</script> is a constant function. If <script type="math/tex">f(x)</script> outputs something different than a previous execution, we know it can’t be a constant function. We’ll immediately break and return a 1 indicating <script type="math/tex">f(x)</script> is a balanced function. Of course, we know it will always be a constant function, but might as well make it work for the balanced function case. A previous version of this post did work with balanced functions, so if you want to dive into that realm, hopefully this code gives you a head start.</p>

<p>Last of all, I included some approximate time keeping in the classical algorithm so we can compare it to the quantum algorithm.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Helper function to convert between base 10 and base 2 (binary) numbers
</span><span class="k">def</span> <span class="nf">dec_to_binary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">2</span><span class="p">:])</span>


<span class="c1"># Input function and number of bits. Returns 0 if f is constant and 1 if f is balanced
</span><span class="k">def</span> <span class="nf">classical_algo</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c1"># Generate random inputs
</span>    <span class="c1"># random_inputs = random.sample(range(2**n), 2**(n-1)+1)  # 2^(n-1) + 1 unique random samples from 0 to 2^n - 1
</span>    <span class="c1"># Generate non_random inputs
</span>    <span class="n">non_random_inputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Convert inputs into 'binary'
</span>    <span class="n">binary_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">non_random_inputs</span><span class="p">:</span>
        <span class="n">binary_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dec_to_binary</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="c1"># Determine if f is balanced or constant
</span>    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialize list to later store outputs
</span>    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>  <span class="c1"># start timing
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">binary_inputs</span><span class="p">):</span>  <span class="c1"># iterate through random inputs
</span>        <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c1"># keep track of f(x) outputs
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>  <span class="c1"># if outputs is different from previous f(x), f must be balanced
</span>                <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>  <span class="c1"># BALANCED FUNCTION
</span>    <span class="c1"># if we get this far, 50% + 1 of the possible inputs gave the same output. Therefore, f must be constant.
</span>    <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>  <span class="c1"># CONSTANT FUNCTION
</span>
</code></pre></div></div>

<h2 id="timed-trial-classical-algorithm">Timed Trial: Classical Algorithm</h2>
<p>Now that we have our algorithm ready and timed, let’s run it! A LOT! We can try a small range of bits and run each <script type="math/tex">n</script> value ~<script type="math/tex">100</script> or more. That should be enough to get some good statistics on its variability. Let’s also see if <script type="math/tex">n</script> vs run time scales like <script type="math/tex">2^{n-1}</script> as the theory suggests. Though I defined two constant functions, I just use the first one here. (It would be interesting to randomly pick between different constant functions. Maybe I’ll do that in another post.)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This will run for 30-40 minutes
</span>
<span class="n">reps</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># number of repeated timings so we can get some statistics
</span><span class="n">ns_con</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>  <span class="c1"># number of bits to consider in algo
</span><span class="n">f_consts</span> <span class="o">=</span> <span class="p">[</span><span class="n">f_const0</span><span class="p">,</span> <span class="n">f_const1</span><span class="p">]</span>

<span class="c1"># Initialize arrays that will store results
</span><span class="n">const_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ns_con</span><span class="p">)</span> <span class="o">*</span> <span class="n">reps</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ns_con</span><span class="p">)</span> <span class="o">*</span> <span class="n">reps</span><span class="p">)</span>

<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ns_con</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ns_con</span><span class="p">)</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">const_time</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">classical_algo</span><span class="p">(</span><span class="n">f_consts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Compute run time means and standard deviations for each n
</span><span class="n">const_time</span> <span class="o">=</span> <span class="n">const_time</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns_con</span><span class="p">))</span>
<span class="n">const_time_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">const_time</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">const_time_stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">const_time</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Check it labeled the function correctly
</span><span class="k">print</span><span class="p">(</span><span class="s">"Average label should be exactly 0:"</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>

<span class="c1"># Conversion factor from seconds to milliseconds
</span><span class="n">millisec</span> <span class="o">=</span> <span class="mf">1e3</span>
<span class="c1"># Conversion factor from seconds to microseconds
</span><span class="n">microsec</span> <span class="o">=</span> <span class="mf">1e6</span>

<span class="c1"># Plot time it took to run algo
</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ns_con</span><span class="p">,</span> <span class="n">const_time_means</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">ns_con</span><span class="p">,</span> <span class="p">(</span><span class="n">const_time_means</span><span class="o">-</span><span class="n">const_time_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> 
                 <span class="p">(</span><span class="n">const_time_means</span><span class="o">+</span><span class="n">const_time_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'k'</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Classical Algo Runtime'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'number of bits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'execution time (milliseconds)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Average label should be exactly 0: 0.0
</code></pre></div></div>

<p><img src="/assets/images/df_9_1.png" alt="png" /></p>

<p>Wow, that’s <strong><em>very</em></strong> exponential—just like we expected! The blue line is the mean runtime for a given number of bits. The gray shadow that outlines the first standard deviation from the mean is so small, it can’t be seen. Let’s fit the means to a function of the form <script type="math/tex">a 2^{b(n-1)} + c</script>. From the theory we talked about before, we expect the runtime <script type="math/tex">T \propto 2^{n-1}</script>, so <script type="math/tex">b</script> should be <script type="math/tex">1</script>. The <script type="math/tex">a</script> and <script type="math/tex">c</script> parameters aren’t important because they’re not part of the exponential. <script type="math/tex">b</script> IS really important because it tells us how fast the exponential grows with <script type="math/tex">n</script>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">c</span>

<span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">ns_con</span><span class="p">,</span> <span class="n">const_time_means</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Fit parameters:"</span><span class="p">,</span> <span class="n">popt</span><span class="p">)</span>
<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ns_con</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ns_con</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">ys</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>

<span class="c1"># Plot mean data points and fit
</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="s">'-m'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ns_con</span><span class="p">,</span> <span class="n">const_time_means</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="s">'.b'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">ns_con</span><span class="p">,</span> <span class="p">(</span><span class="n">const_time_means</span><span class="o">-</span><span class="n">const_time_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> 
                 <span class="p">(</span><span class="n">const_time_means</span><span class="o">+</span><span class="n">const_time_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'k'</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Exponential Fit on Classical Algo Runtime'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'number of bits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'time (milliseconds)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'Fit'</span><span class="p">,</span><span class="s">'Data'</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Fit parameters: [ 3.01288381e-07  9.99435938e-01 -1.31329863e-04]
</code></pre></div></div>

<p><img src="/assets/images/df_11_1.png" alt="png" /></p>

<p><script type="math/tex">b = 0.9994 \approx 1</script>!!! The theory was spot on! This classical algorithm scales just like we expected. Doesn’t it warm your heart when theory and experiment agree with each other? The classical results are all squared away. Next up is the quantum computer.</p>

<h2 id="define-constant-circuits">Define Constant Circuits</h2>
<p>The constant circuits are just as simple as the classical constant functions. The two easiest constant functions are doing nothing (the output is always <script type="math/tex">0</script>), or have an <script type="math/tex">X</script> gate (the output is always <script type="math/tex">1</script>).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Two possible constant U_f operations
</span><span class="k">def</span> <span class="nf">uf_const0</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">output_qubit</span><span class="p">):</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">iden</span><span class="p">(</span><span class="n">output_qubit</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">uf_const1</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">output_qubit</span><span class="p">):</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">output_qubit</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="deterministic-quantum-algorithm-deutsch-jozsa">Deterministic Quantum Algorithm: Deutsch-Jozsa</h2>
<p>Below, I define the Deutsch-Jozsa algorithm in the function <code class="language-plaintext highlighter-rouge">dj_algo_circuit</code> and define a function to run and time it called <code class="language-plaintext highlighter-rouge">quantum_algo</code>. Inside the <code class="language-plaintext highlighter-rouge">dj_algo_circuit</code>, it’s important to use the <code class="language-plaintext highlighter-rouge">circuit.barrier()</code> commands around the <script type="math/tex">U_f</script>. If we don’t, the circuit will be optimized and the since our <script type="math/tex">U_f</script> is so simple, the circuit will be very small. This is kind of cheating because, in theory, we want the algorithm to work for ANY <script type="math/tex">U_f</script> not our cooked up very simple one which the optimizer will literally reduce down to just one or two gates. To tell qiskit to not optimize the whole circuit, we divide it up using the barrier command. It will only optimize gates between barriers or between a barrier and a circuit boundary (i.e. the beginning or end of the circuit).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># uf is the U_f you wish to know whether it is balanced or constant and n is the number of INPUT (not total) qubits
</span><span class="k">def</span> <span class="nf">dj_algo_circuit</span><span class="p">(</span><span class="n">uf</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="n">uf</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">circuit</span>

<span class="k">def</span> <span class="nf">quantum_algo</span><span class="p">(</span><span class="n">uf</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="p">):</span>   
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">dj_algo_circuit</span><span class="p">(</span><span class="n">uf</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">counts</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">time_taken</span>
</code></pre></div></div>

<h2 id="timed-trial-deutsch-jozsa-with-a-5-qubit-quantum-computer">Timed Trial: Deutsch-Jozsa with a 5-Qubit Quantum Computer</h2>
<p>Let’s start with a small 5-qubit quantum computers. First, we’ll find the least busy 5-qubit quantum computer. Then, we’ll take the same approach as the classical algorithm’s timed trial except the repetition number will be 10 instead of 100. Within each repetition, we need to decide how many shots the quantum computer should run. In an earlier version of this notebook, I did one shot per repetition, and the quantum computer classified <script type="math/tex">U_f</script> as constant about 50% of the time—not very good (should be 100%). The more shots, the higher probability of getting the right answer, but also a longer data acquisition time.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IBMQ</span><span class="o">.</span><span class="n">load_account</span><span class="p">()</span> <span class="c1"># Load account from disk
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/Users/Razander/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/ibmqfactory.py:181: UserWarning: Credentials are already in use. The existing account in the session will be replaced.
  warnings.warn('Credentials are already in use. The existing '





&lt;AccountProvider for IBMQ(hub='ibm-q', group='open', project='main')&gt;
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Filter backends to find the least busy 5 qubit quantum computer and check current "pending_jobs"
</span><span class="kn">from</span> <span class="nn">qiskit.providers.ibmq</span> <span class="kn">import</span> <span class="n">least_busy</span>

<span class="n">provider</span> <span class="o">=</span> <span class="n">IBMQ</span><span class="o">.</span><span class="n">get_provider</span><span class="p">(</span><span class="n">hub</span><span class="o">=</span><span class="s">'ibm-q'</span><span class="p">)</span>
<span class="n">smaller_qcs</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">backends</span><span class="p">(</span><span class="n">filters</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span><span class="o">.</span><span class="n">n_qubits</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span><span class="o">.</span><span class="n">simulator</span><span class="p">)</span>
<span class="n">backend_real</span> <span class="o">=</span> <span class="n">least_busy</span><span class="p">(</span><span class="n">smaller_qcs</span><span class="p">)</span>

<span class="c1"># Check status and "pending_jobs" to see how long it might take to run
</span><span class="n">backend_real</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BackendStatus(backend_name='ibmqx2', backend_version='2.0.5', operational=True, pending_jobs=1, status_msg='active')
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reps</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">qs_real_con</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># input qubits only goes up to 4 since last qubit on qc is needed as output qubit
</span><span class="n">shots_real</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># Initialize arrays that will store results
</span><span class="n">q_real_con_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qs_real_con</span><span class="p">)</span> <span class="o">*</span> <span class="n">reps</span><span class="p">)</span>
<span class="n">q_real_con_cs</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># Execute quantum circuit and view results
</span><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qs_real_con</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">qs_real_con</span><span class="p">)</span>
        <span class="n">q_real_con_cs</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">q_real_con_t</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantum_algo</span><span class="p">(</span><span class="n">uf_const0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">backend_real</span><span class="p">,</span> <span class="n">shots_real</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Compute mean and standard deviation from runs
</span><span class="n">q_real_con_t</span> <span class="o">=</span> <span class="n">q_real_con_t</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">qs_real_con</span><span class="p">))</span>
<span class="n">q_real_con_t_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">q_real_con_t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">q_real_con_t_stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">q_real_con_t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Add up number of 0 states from the repeated experiments
</span><span class="n">label_ave</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">rep</span><span class="p">,</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">q_real_con_cs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">zero_state_counts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">other_state_counts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">counts</span> <span class="ow">in</span> <span class="n">exp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="mi">0</span><span class="o">==</span><span class="nb">int</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="n">zero_state_counts</span> <span class="o">+=</span> <span class="n">counts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_state_counts</span> <span class="o">+=</span> <span class="n">counts</span>
    <span class="k">if</span> <span class="n">zero_state_counts</span> <span class="o">&gt;</span> <span class="n">other_state_counts</span><span class="p">:</span>
        <span class="n">label_ave</span> <span class="o">+=</span> <span class="mf">0.0</span>
    <span class="k">elif</span> <span class="n">zero_state_counts</span> <span class="o">==</span> <span class="n">other_state_counts</span><span class="p">:</span>
        <span class="n">label_ave</span> <span class="o">+=</span> <span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">label_ave</span> <span class="o">+=</span> <span class="mf">1.0</span>
<span class="n">zero_state_ave</span> <span class="o">=</span> <span class="n">label_ave</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">q_real_con_cs</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Check it labeled the function correctly
</span><span class="k">print</span><span class="p">(</span><span class="s">"Average label should be exactly 0:"</span><span class="p">,</span> <span class="n">zero_state_ave</span><span class="p">)</span>

<span class="c1"># Plot time it took to run algo
</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">qs_real_con</span><span class="p">,</span> <span class="n">q_real_con_t_means</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">qs_real_con</span><span class="p">,</span> <span class="p">(</span><span class="n">q_real_con_t_means</span><span class="o">-</span><span class="n">q_real_con_t_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> 
                 <span class="p">(</span><span class="n">q_real_con_t_means</span><span class="o">+</span><span class="n">q_real_con_t_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'k'</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Quantum Algo Runtime'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'number of bits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'execution time (milliseconds)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Average label should be exactly 0: 0.1375
</code></pre></div></div>

<p><img src="/assets/images/df_21_1.png" alt="png" /></p>

<p>I might be getting ahead of myself but that looks NOT exponential! With so few data points it’s really hard to be certain. Let’s see what the fit parameters say. Notice the “Average label should be exactly 0:” value is <script type="math/tex">0.1375</script>. That means the quantum computer miscategorized the function <script type="math/tex">13.75</script>% of the time. I’d say that’s pretty good, but still not great. Doing more shots would reduce this further.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">popt_exp</span><span class="p">,</span> <span class="n">pcov_exp</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">qs_real_con</span><span class="p">,</span> <span class="n">q_real_con_t_means</span><span class="p">)</span>
<span class="n">popt_lin</span><span class="p">,</span> <span class="n">pcov_lin</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">linear</span><span class="p">,</span> <span class="n">qs_real_con</span><span class="p">,</span> <span class="n">q_real_con_t_means</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Exponential fit parameters:"</span><span class="p">,</span> <span class="n">popt_exp</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Linear fit parameters:"</span><span class="p">,</span> <span class="n">popt_lin</span><span class="p">)</span>
<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">ys_exp</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="o">*</span><span class="n">popt_exp</span><span class="p">)</span>
<span class="n">ys_lin</span> <span class="o">=</span> <span class="n">linear</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="o">*</span><span class="n">popt_lin</span><span class="p">)</span>

<span class="c1"># Plot mean data points and fit
</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys_exp</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="s">'-m'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys_lin</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="s">'-g'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">qs_real_con</span><span class="p">,</span> <span class="n">q_real_con_t_means</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="s">'-b'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">qs_real_con</span><span class="p">,</span> <span class="p">(</span><span class="n">q_real_con_t_means</span><span class="o">-</span><span class="n">q_real_con_t_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> 
                 <span class="p">(</span><span class="n">q_real_con_t_means</span><span class="o">+</span><span class="n">q_real_con_t_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'k'</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Exponential Fit on Quantum Algo Runtime'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'number of bits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'time (milliseconds)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'Exponential Fit'</span><span class="p">,</span> <span class="s">'Linear Fit'</span><span class="p">,</span> <span class="s">'Data'</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exponential fit parameters: [0.03436465 0.78291723 2.21614698]
Linear fit parameters: [0.04600616 2.19370074]
</code></pre></div></div>

<p><img src="/assets/images/df_23_1.png" alt="png" /></p>

<p>As I said, by eye, it really could be linear or exponential. The fit parameters don’t help us much. If it is exponential, the important parameter <script type="math/tex">b</script> is already less than 1, so that’s improvement from the classical case, but it’s definitely possibly exponential. There just aren’t enough data points to distinguish between a linear and exponential trend. Luckily, IBM has a 15-qubit quantum computer available! :D Let’s try that. For sake of time, I only ran 1 repetition, so there are no statistics.</p>

<h2 id="timed-trial-deutsch-jozsa-with-a-15-qubit-quantum-computer">Timed Trial: Deutsch-Jozsa with a 15-Qubit Quantum Computer</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">backend_bigqc</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s">'ibmq_16_melbourne'</span><span class="p">)</span>
<span class="n">backend_bigqc</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BackendStatus(backend_name='ibmq_16_melbourne', backend_version='2.0.6', operational=True, pending_jobs=6, status_msg='active')
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reps</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">qs_realbig_con</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>  <span class="c1"># input qubits only goes up to 14 since last qubit on qc is needed as output qubit
</span><span class="n">shots_real</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Initialize arrays that will store results
</span><span class="n">q_realbig_con_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qs_realbig_con</span><span class="p">)</span> <span class="o">*</span> <span class="n">reps</span><span class="p">)</span>
<span class="n">q_realbig_con_cs</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># Execute quantum circuit and view results
</span><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qs_realbig_con</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">qs_realbig_con</span><span class="p">)</span>
        <span class="n">q_realbig_con_cs</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">q_realbig_con_t</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantum_algo</span><span class="p">(</span><span class="n">uf_const0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">backend_bigqc</span><span class="p">,</span> <span class="n">shots_real</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Compute mean and standard deviation from runs
</span><span class="n">q_realbig_con_t</span> <span class="o">=</span> <span class="n">q_realbig_con_t</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">qs_realbig_con</span><span class="p">))</span>
<span class="n">q_realbig_con_t_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">q_realbig_con_t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">q_realbig_con_t_stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">q_realbig_con_t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Add up number of 0 states from the repeated experiments
</span><span class="n">label_ave</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">key1</span><span class="p">,</span> <span class="n">val1</span> <span class="ow">in</span> <span class="n">q_realbig_con_cs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">key2</span><span class="p">,</span> <span class="n">val2</span> <span class="ow">in</span> <span class="n">val1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="mi">0</span><span class="o">==</span><span class="nb">int</span><span class="p">(</span><span class="n">key2</span><span class="p">):</span>
            <span class="n">label_ave</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">zero_state_ave</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">label_ave</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">q_realbig_con_cs</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Check it labeled the function correctly
</span><span class="k">print</span><span class="p">(</span><span class="s">"Average label should be exactly 0:"</span><span class="p">,</span> <span class="n">zero_state_ave</span><span class="p">)</span>

<span class="c1"># Plot time it took to run algo
</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">qs_realbig_con</span><span class="p">,</span> <span class="n">q_realbig_con_t_means</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">qs_realbig_con</span><span class="p">,</span> <span class="p">(</span><span class="n">q_realbig_con_t_means</span><span class="o">-</span><span class="n">q_realbig_con_t_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> 
                 <span class="p">(</span><span class="n">q_realbig_con_t_means</span><span class="o">+</span><span class="n">q_realbig_con_t_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'k'</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Quantum Algo Runtime'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'number of bits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'execution time (milliseconds)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Average label should be exactly 0: 0.7857142857142857
</code></pre></div></div>

<p><img src="/assets/images/df_29_1.png" alt="png" /></p>

<p>Now <strong>THAT</strong> looks NOT exponential! Beautiful!! The theory says it should be flat, but some slope is not a problem. It can easily be swept under the rug as overhead in using more gates for higher qubit numbers or something like that. The important point is that IT’S NOT EXPONENTIAL! Sure enough, if you look at the fit parameter on the exponent (not plotted, but still computed below), it’s very small <script type="math/tex">b=0.0000340</script> implying a linear fit is the right one to use. Notice the miscategorization percentage is <script type="math/tex">78.57</script>%. This is so high because I only ran this with <script type="math/tex">1</script> shot. If I were to increase the number of shots, the percentage would lower.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">popt_exp</span><span class="p">,</span> <span class="n">pcov_exp</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">qs_realbig_con</span><span class="p">,</span> <span class="n">q_realbig_con_t_means</span><span class="p">,</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="n">popt_lin</span><span class="p">,</span> <span class="n">pcov_lin</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">linear</span><span class="p">,</span> <span class="n">qs_realbig_con</span><span class="p">,</span> <span class="n">q_realbig_con_t_means</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Exponential fit parameters:"</span><span class="p">,</span> <span class="n">popt_exp</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Linear fit parameters:"</span><span class="p">,</span> <span class="n">popt_lin</span><span class="p">)</span>

<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">qs_realbig_con</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qs_realbig_con</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">ys_exp</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="o">*</span><span class="n">popt_exp</span><span class="p">)</span>
<span class="n">ys_lin</span> <span class="o">=</span> <span class="n">linear</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="o">*</span><span class="n">popt_lin</span><span class="p">)</span>

<span class="c1"># Plot mean data points and fit
</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys_lin</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="s">'-g'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">qs_realbig_con</span><span class="p">,</span> <span class="n">q_realbig_con_t_means</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="s">'-b'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">qs_realbig_con</span><span class="p">,</span> <span class="p">(</span><span class="n">q_realbig_con_t_means</span><span class="o">-</span><span class="n">q_realbig_con_t_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> 
                 <span class="p">(</span><span class="n">q_realbig_con_t_means</span><span class="o">+</span><span class="n">q_realbig_con_t_stds</span><span class="p">)</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'k'</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Linear Fit on Quantum Algo Runtime'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'number of bits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'time (milliseconds)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'Linear Fit'</span><span class="p">,</span><span class="s">'Data'</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exponential fit parameters: [ 2.07463601e+03  3.40429123e-05 -2.07079676e+03]
Linear fit parameters: [0.04896331 3.79026877]
</code></pre></div></div>

<p><img src="/assets/images/df_31_1.png" alt="png" /></p>

<h1 id="when-does-qc-beat-c">When does QC Beat C?</h1>

<p>With the fits from the classical and quantum runs, we can answer some real life questions like: how many inputs bits/qubits does a 2020 quantum computer need to beat a 2020 laptop?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">quan_popt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.04896331</span><span class="p">,</span> <span class="mf">3.79026877</span><span class="p">]</span>
<span class="n">clas_popt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">3.01288381e-07</span><span class="p">,</span>  <span class="mf">9.99435938e-01</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.31329863e-04</span><span class="p">]</span>

<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">ys_q_lin</span> <span class="o">=</span> <span class="n">linear</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="o">*</span><span class="n">quan_popt</span><span class="p">)</span>
<span class="n">ys_c_exp</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="o">*</span><span class="n">clas_popt</span><span class="p">)</span>

<span class="c1"># Plot mean data points and fit
</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys_q_lin</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="s">'-g'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys_c_exp</span> <span class="o">*</span> <span class="n">millisec</span><span class="p">,</span> <span class="s">'-b'</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Quantum vs Classical  Fit on Quantum Algo Runtime'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'number of bits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'time (milliseconds)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'Quantum Computer'</span><span class="p">,</span><span class="s">'Classical Computer'</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/images/df_33_0.png" alt="png" /></p>

<p>Answer: <script type="math/tex">\gt25</script>! Looks like at <script type="math/tex">25</script> input bits/qubits is where the two are evenly matched, but after that the quantum computer would be WAY (exponentially in fact) faster!</p>

<h2 id="age-of-the-universe-calculation">Age of the Universe Calculation</h2>
<p>At what point will the classical computer take the age of the universe just to discover our chosen <script type="math/tex">f(x)</script> is constant? Let’s assume the age of the universe is ~<script type="math/tex">14</script> billion years—about <script type="math/tex">4.418 \cdot 10^{17}</script> seconds—and solving the exponential fit equation for <script type="math/tex">n</script> gives <script type="math/tex">n = \frac{\ln{\left(\frac{f(x) - c}{a}\right)}}{b\ln(2)} + 1</script>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">age_of_uni_y</span> <span class="o">=</span> <span class="mf">14e9</span>  <span class="c1"># age of the universe in years
</span><span class="n">age_of_uni_s</span><span class="o">=</span> <span class="n">age_of_uni_y</span> <span class="o">*</span> <span class="mf">365.25</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">3600</span>  <span class="c1"># age of the universe in seconds
</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">age_of_uni_s</span> <span class="o">-</span> <span class="n">clas_popt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">clas_popt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">clas_popt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Number of input bits:'</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Number of input bits: 81
</code></pre></div></div>

<p><script type="math/tex">81</script>! Hahaha that’s still double digits! That’s NOTHING! The best part about this is we’re almost there! Google, IBM, IonQ, and others are already have quantum computers in the 30s - 50s of qubits!</p>

  </div><a class="u-url" href="/2020/04/06/Real-Life-Deutsch-Jozsa-Exponential-Speed-up-Test.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Applied Quantum Computation</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Applied Quantum Computation</li><li><a class="u-email" href="mailto:quantumrepeater@gmail.com">quantumrepeater@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/applied-quantum-computing"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">applied-quantum-computing</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Quantum algorithms explained, computed, and tutorialized.</p>
        <p>Want to contribute? See how to <a href=https://appliedqc.org/about/>contact us<a/>.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
